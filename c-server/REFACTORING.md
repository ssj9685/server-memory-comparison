# 리팩터링 메모

## 목표
- 동작은 유지하면서 읽기 쉬운 구조와 명확한 책임 분리를 만들기.
- 에러·자원 처리 흐름을 한눈에 파악할 수 있도록 정리하기.

## 주요 변경 사항
- 공용 모듈 분리: 신호 유틸(`signals.h/.c`), 네트워크 유틸(`net.h/.c`), HTTP 응답 생성(`http.h/.c`), 엔트리 포인트(`server.c`)로 나눠 재사용성과 테스트 용이성을 확보.
- 구조체 도입: `ServerConfig`(포트·백로그), `Listener`(리스닝 fd), `HttpResponse`(버퍼·길이)로 같은 도메인 데이터를 묶어 의미를 드러냄.
- 함수 포인터 집합: `NetOps`/`HttpOps`에 동작을 묶어 C에서도 “메서드” 스타일을 흉내내고, 교체 가능한 구현을 열어둠(예: 모의 객체, 다른 전송 스택).
- 신호 설정 단일 객체화: `SignalOps`가 내부 플래그를 가진 채 `install`로 등록하고, 루프는 `get_flag`로 접근(단일 설치만 허용).
- 상수 정리: 포트/백로그/버퍼 사이즈를 매크로로 정의하고, 기본 본문(`DEFAULT_BODY`)을 분리해 매직 넘버 제거.
- 소켓 초기화 캡슐화: `NetOps.open`이 `socket` → 옵션 설정 → `bind` → `listen`을 처리하고, 실패 시 즉시 정리하도록 구성.
- 응답 생성 유지/명확화: `HttpContext`가 내부 `HttpOps`로 응답을 한 번만 만들어 `HttpResponse`를 재사용(`create_http_context`/`destroy_http_context`).
- 전송 유틸: `NetOps.send_all`로 부분 전송을 반복 처리해 응답 전체가 나가도록 명시.
- 신호 처리 일반화: `SignalOps.install`이 내부 플래그를 활성화해 EINTR 기반 종료를 공용 패턴으로 제공하고 SIGPIPE를 무시.
- 오류 정리 일원화: `goto cleanup` 패턴으로 리소스 해제를 한 곳으로 모아 누락 위험을 줄임.
- 네트 컨텍스트 생성자: `create_net_context`로 `Listener`와 `NetOps`를 함께 받아 초기화 및 해제를 단순화.
- 네임스페이스형 파서: 포트 파서는 `NetOps.parse_port`를 통해 모듈 소속을 드러내면서 외부 노출을 줄임.
- 플래그 주입 대신 기본 내장 플래그 사용: 공용 static 플래그 없이 ops 생성 시 기본 플래그를 세팅해 라이브러리 사용 시에도 동일 패턴 유지.
- `main` 단순화: 설정 로드 → 응답 준비 → 리스닝 소켓 생성 → 루프 처리 순서가 고수준에서 바로 읽히도록 재구성.

## 적용한 이론/패턴
- 함수 포인터 기반 “메서드”: C에서 객체 지향 패턴을 흉내내어 의존성 교체(테스트 더블, 다른 전송 방식)를 열어둠.
- 단일 책임 & 단계화: 각각의 모듈/함수가 한 역할만 맡도록 나눠 의도와 실패 지점을 드러냄.
- 데이터 캡슐화: 구조체로 관련 필드를 묶어 타입 수준에서 의미를 강제하고, 함수 시그니처를 간결하게 유지.
- 신호 객체화: 종료 플래그와 설치 동작을 한 객체(`SignalOps`)로 묶어 “설치 대상 + 동작”을 함께 전달하고, 기본 플래그를 제공(플래그 주입 없이 공용 패턴 유지).
- 호출자 주입형 신호: `create_signal_ops`로 ops를 만들고 `set_flag` → `install` 시 플래그 포인터를 넘겨 라이브러리 사용 시 인스턴스별 종료 플래그를 둘 수 있도록 함(공유 static 제거).
- 조기 반환과 정리: 실패 시 즉시 반환하고, 생성한 리소스(소켓/버퍼)는 같은 스코프에서 닫아 누수를 방지.
- 신호 처리: `SA_RESTART`를 끄고 EINTR을 확인해 SIGINT/SIGTERM 시 `accept`가 풀리며 종료할 수 있게 함. SIGPIPE 무시는 클라이언트 조기 종료로 인한 프로세스 종료를 막기 위함.
- 사전 계산된 불변 응답: Content-Length를 포함한 응답을 미리 만들어 재사용함으로써 반복 포맷팅/할당을 줄이고 스레드 안전한 상수 데이터를 제공.
- 매크로 충돌 최소화: 길이 매크로를 `SMC_ARRAY_LEN`으로 한정해 사용 후 `signals.c`에서 `#undef` 처리하여 외부 영향 최소화.
- 네트워크 관례: `SO_REUSEADDR`로 빠른 재시작 지원, 블로킹 I/O 루프에서 EINTR 처리로 예측 가능한 흐름 확보.
- 신호 목록 명시: 종료 신호 집합(SIGINT/SIGTERM)과 무시 신호 집합(SIGPIPE)을 배열로 관리해 향후 확장 시 한 곳에서 추가/수정 가능하게 유지.

## 추가 개선 아이디어 (현재 범위 밖)
- 요청 드레이닝을 비블로킹/루프 기반으로 확장해 큰 요청도 완전히 읽어들이기.
- 간단한 라우팅·메트릭 수집·로그 포맷 추가로 관찰성 강화.
- 멀티스레드 또는 이벤트 루프(libevent/epoll/kqueue) 기반으로 전환해 동시성 확보.
